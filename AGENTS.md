# AGENTS.md — Architectural Decisions for zlipstream

This document summarizes all architectural decisions made for **zlipstream**, a user-space file-extension virtualization layer featuring transparent on-the-fly format transformation.

## 1. Overview

**zlipstream** is a system-level user-space middleware that allows any program to open files in formats that do not actually exist on disk.

For example:

```
# only a.svg exists
gimp a.png     → works via transparent conversion
```

zlipstream intercepts file operations, generates *virtual* files using an internal conversion engine, and — when writes occur — materializes the corresponding real file on disk.

The system works **globally**, for **all user processes**, without wrappers, without modified PATH, without FUSE, and without kernel modules.

## 2. File Virtualization Model

### 2.1 Virtual Extensions

For a real file `base.extA`, zlipstream exposes fictional variants such as:

```
base.extB
base.extC
```

These may be:

- **Visible** (shown in directory listings)
- **Invisible** (resolved only when opened)

This is configurable.

### 2.2 Persistence Rules

Virtual files become permanent when:

- They are opened with write flags
- A program writes to them
- A rename targets a virtual extension:

```
mv file.md file.pdf → triggers real conversion
```

Writes or renames yield a real file on disk via the conversion engine.

## 3. Interception Layer

### 3.1 Injection Model

zlipstream uses a **user-space injection daemon** that ensures global LD_PRELOAD interposition without requiring shell wrappers.

The daemon:

1. Monitors processes created by the user
2. Injects `libzlipstream.so` before `execve()`
3. Ensures interposition for all programs (shell, GUI, IDEs, launchers)

### 3.2 Interposed Functions

`libzlipstream.so` overrides:

- `open`, `openat`
- `stat`, `lstat`, `fstatat`
- `rename`, `renameat`, `renameat2`
- `unlink`
- `readdir` (depending on visibility setting)

Fallback behavior always calls the real libc functions if no virtual rule applies.

## 4. Internal Conversion Engine (GhostFX)

To avoid external dependencies, zlipstream ships with an internal pipeline-based conversion system.

### 4.1 Core Primitives

- **Text/Markup**
  - Markdown → HTML
  - HTML → PDF (simple internal generator)

- **Images**
  - PNG/JPEG/WebP decode/encode
  - Basic SVG rasterization

- **Structured Data**
  - JSON ↔ YAML ↔ TOML

- **Archives**
  - zip/tar/gzip minimal transforms

External tools may be used optionally, but never as required dependencies.

### 4.2 Pipelines

A rule looks like:

```toml
[[rule]]
from = "md"
to   = "pdf"
pipeline = ["parse_md", "render_html", "render_pdf_simple"]

[[rule]]
from = "svg"
to   = "png"
pipeline = ["raster_svg_basic", "encode_png"]

[[rule]]
from = "json"
to   = "yaml"
pipeline = ["parse_json", "render_yaml"]
```

Pipelines operate entirely in memory and return bytes representing the virtual file.

## 5. Behavior of Rename / Move

`mv file.extA file.extB` triggers a real conversion if `extB` is a supported virtual extension.

The result is written to disk as a permanent file, replacing or removing the source depending on standard `mv` semantics.

## 6. Visibility Modes

Two modes:

- **Visible virtual extensions:** shown in directory listings via `readdir` interposition
- **Invisible virtual extensions:** generated only when accessed

Switchable in configuration.

## 7. Configuration

A config file (TOML/YAML) describes:

- Which extensions can be virtually exposed
- Which pipelines apply for conversion
- Visibility mode
- External tool fallbacks (optional)

## 8. Process

### Read path

1. Program attempts to open `target.extB`
2. If the file does not exist:
   - zlipstream checks for a rule `extA → extB`
   - If rule exists and `base.extA` is present,
     - GhostFX generates the virtual file
3. File descriptor corresponds to generated bytes

### Write path

1. Program writes to virtual file
2. zlipstream materializes a permanent converted file on disk

### Rename path

`rename(old, new)` is intercepted:
- If `new.ext` is a virtual extension → pipeline executes → real file created

## 9. Summary

zlipstream acts as a transparent, global, user-space file format virtualization layer with:

- Full process coverage via injection daemon
- Internal conversion engine
- Configurable virtual extension visibility
- Correct write/rename semantics
- Zero required external dependencies

It effectively behaves like a “format-shapeshifting filesystem layer” without modifying kernel or filesystem drivers.
